<html lang="en">

<head>
  <link rel="icon" type="image/png" href="misc/favicon-32x32.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="misc/favicon-16x16.png" sizes="16x16" />

  <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet">
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <title>go-seq</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="/js/jquery.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  <script src="/js/header.js"></script>
  <script src="/js/toc.js"></script>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/theme.css" rel="stylesheet">
  <link href="/css/font-awesome/css/font-awesome.min.css" rel="stylesheet">
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/x-mathjax-config">
	MathJax.Hub.Config({
		tex2jax: {
			inlineMath: [ ['$','$'], ["\\(","\\)"] ],
			displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
			processEscapes: false
		},
		"HTML-CSS": {
			preferredFont: "TeX",
		}
	})
  </script>
  <link href="/css/syntax.css" rel="stylesheet">
</head>

<body>

  

  


  <nav class="navbar navbar-inverse">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">go-seq</a>
      </div>
      <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="/">/home</a></li>
          <li><a href="/archive.html">/archive</a></li>
          <li><a href="/tags.html">/tags</a></li>
          <li><a href="/about.html">/about</a></li>
          <li><a href="/feed.xml">/RSS</a></li>
        </ul>
      </div>
    </div>
  </nav>


<div class="wrapper">
  <div class="content">
    <div class="container container-center">
      <div class="row">
        <div class="col-md-12">
          <div class="article">
            <div class="well">
              <h1><a href="/2016/11/polyclojure3">Polymorphism in Clojure: A Tutorial Using Numbers, Part 3</a></h1>
              <div class="post-meta">
                <div class="post-time">
                  <i class="fa fa-calendar"></i>
                  <time>23 Nov 2016</time>
                </div>
                <ul>
                  
                    <li><a href="/tag/clojure">clojure</a></li>
                  
                    <li><a href="/tag/polymorphism">polymorphism</a></li>
                  
                    <li><a href="/tag/functional-programming">functional-programming</a></li>
                  
                </ul>
              </div>
              <div class="post-content">
                <div id="toc" class="toc"></div>
                <p><em>This post is composed of 3 parts: <a href="/2016/11/polyclojure1">Part 1</a>, <a href="/2016/11/polyclojure2">Part 2</a>, Part 3</em></p>

<h2 id="arithmetic-with-mixed-types">Arithmetic with Mixed Types</h2>

<p>We have so far built a number system with five different types and an <code>add</code> function that can take any two numbers of the same type and add them together with the same interface. </p>

<p>However what if I wanted to <code>add</code> a <code>Complex-r</code> and a <code>Real</code> together? We would need to convert the <code>Real</code> to a <code>Complex-r</code> and then add them together. We could do this by adding more multimethods:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defmethod </span><span class="nv">add</span> <span class="p">[</span><span class="ss">::complex-r</span> <span class="ss">::real</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">...</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">add</span> <span class="p">[</span><span class="ss">::real</span> <span class="ss">::complex-r</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">...</span><span class="p">))</span>
</code></pre></div>
<p>You can see that doing this for all combinations of types would lead to a combinatorial explosion of new multimethods! Clojure&#39;s hierarchies can enable us to solve this problem without the need to write a factorial number of functions.</p>

<p>We can side-step the problem of writing a combinatorical number of new functions by noting that to add two different types of number together we have to promote one of the numbers to be the same type as the other. With this in mind we can create a catch-all method for <code>add</code> that catches all the cases of mixed types, coerces the types to be the same and then calls <code>add</code> again with the converted types. It will then call one of the previously defined <code>add</code> methods where the types are the same. </p>

<p>We can implement the catch-all case by creating a new abstraction <code>::number</code> at the top of the hierarchy where every number we have created so far is a descendant of <code>::number</code>:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">derive</span> <span class="ss">::complex</span> <span class="ss">::number</span><span class="p">)</span>
<span class="p">(</span><span class="nf">derive</span> <span class="ss">::integer</span> <span class="ss">::number</span><span class="p">)</span>
<span class="p">(</span><span class="nf">derive</span> <span class="ss">::float</span> <span class="ss">::number</span><span class="p">)</span>
<span class="p">(</span><span class="nf">derive</span> <span class="ss">::rational</span> <span class="ss">::number</span><span class="p">)</span>
</code></pre></div>
<p>We can now create the catch-all <code>add</code> method that will that will matc <code>[::number ::number]</code>:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defmethod </span><span class="nv">add</span> <span class="p">[</span><span class="ss">::number</span> <span class="ss">::number</span><span class="p">]</span>
  <span class="p">[</span><span class="nv">n1</span> <span class="nv">n2</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">apply </span><span class="nv">add</span> <span class="p">(</span><span class="nf">coerce-types</span> <span class="nv">n1</span> <span class="nv">n2</span><span class="p">)))</span>
</code></pre></div>
<p>This works because any combination of different types will fail all the rules of the other multimethods except this one, because all of our types are descendants of <code>::number</code>. This method then calls the coercion function (which I will define later) to convert the arguments into the same type and then calls the <code>add</code> multi-function with these converted arguments. This will then find the correct multimethod for the now uniform types return the result. </p>

<h2 id="type-coercion-with-the-numeric-tower">Type Coercion with the Numeric Tower</h2>

<p>We can convert any Integer to a Rational without a loss of information. You cannot convert any Rational to an Integer without a loss of information though. Similarly any Rational can be converted to a Float, and any Float can be converted to a Complex number.</p>

<p>This chain of conversions is the <strong>numeric tower</strong>:</p>

<ul>
<li>Integer -&gt; Rational -&gt; Float -&gt; Complex<br></li>
</ul>

<p>We want to be able to call a function <code>raise</code> on one of our types and get back the same numeric value, but represent by the next type in the tower. The function depends on the type of the argument so we can create another protocol:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defprotocol </span><span class="nv">PRaise</span>
  <span class="p">(</span><span class="nf">raise</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="s">&quot;raises a number type to the next type</span>
<span class="s">          in the numeric tower with equivalent value&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">extend-protocol</span> <span class="nv">PRaise</span>
  <span class="nv">Int</span>
  <span class="p">(</span><span class="nf">raise</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">rational</span> <span class="p">(</span><span class="ss">:n</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>

  <span class="nv">Rational</span>
  <span class="p">(</span><span class="nf">raise</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">float </span><span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">numer</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">double </span><span class="p">(</span><span class="nf">denom</span> <span class="nv">x</span><span class="p">)))))</span>

  <span class="nv">Float</span>
  <span class="p">(</span><span class="nf">raise</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">complex-r</span> <span class="p">(</span><span class="ss">:n</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">0</span><span class="p">)))</span>
</code></pre></div>
<p>Given a pair of types, e.g. <code>[::integer ::float]</code>, we need a way to encode the fact that <code>::float</code> is higher in the tower than <code>::integer</code>, and so <code>::integer</code> needs to be raised until it is a <code>::float</code>. This could be done with a map associating the types to a rank number, but this is pretty inflexible if we add more types. </p>

<p>The numeric tower is a hierarchy so we are actually better off using Clojure&#39;s ad-hoc hierarchies again. In Clojure there is a global hierarchy structure which we have used so far for the arithmetic, but you are free to create your own hierarchies with <code>make-hierarchy</code>. This exists independently of the global hierarchy we used earlier. This is handy because the numeric tower hierarchy is different from the arithmetic hierarchy.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">numeric-tower</span>
  <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">make-hierarchy</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">derive</span> <span class="ss">::complex</span> <span class="ss">::complex-p</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">derive</span> <span class="ss">::complex</span> <span class="ss">::complex-r</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">derive</span> <span class="ss">::float</span> <span class="ss">::complex</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">derive</span> <span class="ss">::rational</span> <span class="ss">::float</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">derive</span> <span class="ss">::integer</span> <span class="ss">::rational</span><span class="p">)))</span>
</code></pre></div>
<p>Using this we can create comparator functions for two keyword types. For example:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">higher?</span> <span class="ss">::float</span> <span class="ss">::integer</span><span class="p">)</span>
<span class="nv">true</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">lower?</span> <span class="ss">::rational</span> <span class="ss">::complex-r</span><span class="p">)</span>
<span class="nv">true</span>
</code></pre></div>
<p>These are easy to implement using the functions for querying hierarchies, <code>ancestors</code> and <code>descendents</code>:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">higher?</span>
  <span class="s">&quot;Is type 1 higher in the numeric tower than type 2?&quot;</span>
  <span class="p">[</span><span class="nv">t1</span> <span class="nv">t2</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">contains? </span><span class="p">(</span><span class="nf">ancestors</span> <span class="nv">numeric-tower</span> <span class="nv">t2</span><span class="p">)</span> <span class="nv">t1</span><span class="p">)</span>
    <span class="nv">true</span>
    <span class="nv">false</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">lower?</span>
  <span class="s">&quot;Is type 1 lower in the numeric tower than type 2?&quot;</span>
  <span class="p">[</span><span class="nv">t1</span> <span class="nv">t2</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">contains? </span><span class="p">(</span><span class="nf">descendants</span> <span class="nv">numeric-tower</span> <span class="nv">t2</span><span class="p">)</span> <span class="nv">t1</span><span class="p">)</span>
    <span class="nv">true</span>
    <span class="nv">false</span><span class="p">))</span>
</code></pre></div>
<p>With these functions we can implement <code>coerce-types</code>:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">coerce-types</span>
  <span class="s">&quot;Given two different number types raise the lesser type up</span>
<span class="s">  to be the same as the greater type&quot;</span>
  <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">t1</span> <span class="p">(</span><span class="nf">kind</span> <span class="nv">x</span><span class="p">)</span>
        <span class="nv">t2</span> <span class="p">(</span><span class="nf">kind</span> <span class="nv">y</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">(</span><span class="nf">lower?</span> <span class="nv">t1</span> <span class="nv">t2</span><span class="p">)</span> <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nf">raise</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">higher?</span> <span class="nv">t1</span> <span class="nv">t2</span><span class="p">)</span> <span class="p">(</span><span class="nf">recur</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">raise</span> <span class="nv">y</span><span class="p">))</span>
      <span class="ss">:else</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">])))</span> 
</code></pre></div>
<p>Trying this out in a REPL:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">raise</span> <span class="p">(</span><span class="nf">integer</span> <span class="mi">3</span><span class="p">))</span>
<span class="o">#</span><span class="nv">numbers.core.Rational</span><span class="p">{</span><span class="ss">:n</span> <span class="mi">3</span>, <span class="ss">:d</span> <span class="mi">1</span><span class="p">}</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">raise</span> <span class="p">(</span><span class="nb">float </span><span class="mi">4</span><span class="p">))</span>
<span class="o">#</span><span class="nv">numbers.core.Complex-r</span><span class="p">{</span><span class="ss">:real</span> <span class="mf">4.0</span>, <span class="ss">:imag</span> <span class="mi">0</span><span class="p">}</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">coerce-types</span> <span class="p">(</span><span class="nf">integer</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">rational</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>
<span class="p">[</span><span class="o">#</span><span class="nv">numbers.core.Rational</span><span class="p">{</span><span class="ss">:n</span> <span class="mi">4</span>, <span class="ss">:d</span> <span class="mi">1</span><span class="p">}</span> <span class="o">#</span><span class="nv">numbers.core.Rational</span><span class="p">{</span><span class="ss">:n</span> <span class="mi">5</span>, <span class="ss">:d</span> <span class="mi">6</span><span class="p">}]</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">coerce-types</span> <span class="p">(</span><span class="nf">rational</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="nf">complex-r</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>
<span class="p">[</span><span class="o">#</span><span class="nv">numbers.core.Complex-r</span><span class="p">{</span><span class="ss">:real</span> <span class="mf">0.8333333333333333</span>, <span class="ss">:imag</span> <span class="mi">0</span><span class="p">}</span> <span class="o">#</span><span class="nv">numbers.core.Complex-r</span><span class="p">{</span><span class="ss">:real</span> <span class="mi">7</span>, <span class="ss">:imag</span> <span class="mi">8</span><span class="p">}]</span>
</code></pre></div>
<h2 id="final-product-and-further-ideas">Final Product and Further Ideas</h2>

<p>We have implemented a number system that can represent integers, floating point numbers, rational numbers, rectangular complex numbers, and polar complex numbers. It can perform basic binary arithmetic operations add, subtract, multiply, and divide on any combination of number types.</p>

<p>Let&#39;s demonstrate the final product in the REPL:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">add</span> <span class="p">(</span><span class="nf">integer</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">integer</span> <span class="mi">6</span><span class="p">))</span>
<span class="o">#</span><span class="nv">numbers.core.Int</span><span class="p">{</span><span class="ss">:n</span> <span class="mi">10</span><span class="p">}</span>

<span class="p">(</span><span class="nf">add</span> <span class="p">(</span><span class="nf">integer</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nb">float </span><span class="mi">6</span><span class="p">))</span>
<span class="o">#</span><span class="nv">numbers.core.Float</span><span class="p">{</span><span class="ss">:n</span> <span class="mf">10.0</span><span class="p">}</span>

<span class="p">(</span><span class="nf">add</span> <span class="p">(</span><span class="nf">rational</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="nb">float </span><span class="mi">6</span><span class="p">))</span>
<span class="o">#</span><span class="nv">numbers.core.Float</span><span class="p">{</span><span class="ss">:n</span> <span class="mf">6.833333333333333</span><span class="p">}</span>

<span class="p">(</span><span class="nf">mul</span> <span class="p">(</span><span class="nb">float </span><span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="nf">complex-p</span> <span class="mi">10</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="o">#</span><span class="nv">numbers.core.Complex-p</span><span class="p">{</span><span class="ss">:magnitude</span> <span class="mf">60.0</span>, <span class="ss">:angle</span> <span class="mf">0.5</span><span class="p">}</span>

<span class="p">(</span><span class="nf">div</span> <span class="p">(</span><span class="nf">integer</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nf">rational</span> <span class="mi">7</span> <span class="mi">5</span><span class="p">))</span>
<span class="o">#</span><span class="nv">numbers.core.Rational</span><span class="p">{</span><span class="ss">:n</span> <span class="mi">25</span>, <span class="ss">:d</span> <span class="mi">7</span><span class="p">}</span>

<span class="p">(</span><span class="nf">div</span> <span class="p">(</span><span class="nf">integer</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nf">complex-r</span> <span class="mi">7</span> <span class="mi">5</span><span class="p">))</span>
<span class="o">#</span><span class="nv">numbers.core.Complex-p</span><span class="p">{</span><span class="ss">:magnitude</span> <span class="mf">0.5812381937190965</span>, <span class="ss">:angle</span> <span class="mf">-0.6202494859828215</span><span class="p">}</span>
</code></pre></div>
<p>Seems to work fairly well!</p>

<p>I could continue building on this, but that would be beyond the scope of this blog post. There are a few things worth thinking about nonetheless. One aesthetic improvement would be implementing a pretty REPL representation of the custom number types. E.g. having <code>3/4</code> instead of <code>Rational(:n 3 :d 4)</code>. Clojure has a single function that takes care of printing things: <code>clojure.lang.print-method</code>. This is simply another multimethod like we&#39;ve already been using. Adding nicer printing is straight-forward:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="c1">;; nicer printing for rationals</span>
<span class="p">(</span><span class="kd">defmethod </span><span class="nv">print-method</span> <span class="nv">Rational</span> <span class="p">[</span><span class="nv">x</span> <span class="o">^</span><span class="nv">java.io.Writer</span> <span class="nv">writer</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">.write</span> <span class="nv">writer</span> <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nf">numer</span> <span class="nv">x</span><span class="p">)</span> <span class="sc">\/</span> <span class="p">(</span><span class="nf">denom</span> <span class="nv">x</span><span class="p">))))</span>

<span class="c1">;; and similarly for the other types...</span>
<span class="c1">;; ...</span>
</code></pre></div>
<p>In SICP there is also an exercise to extend the number system to be implemented purely with its own types. So while Integer and Float types would be wrappers for Clojure&#39;s own types, the Rational, Complex-r, and Complex-p types could themselves be composed of any of the other types. So you could have a Rational number whose demoninator and numerator were complex numbers. Or conversely a complex number whose real and imaginary parts were rational numbers. This would be achieved with some modification to the existing code. You would need to replace all uses of Clojure&#39;s primitive arithmetic functions (<code>+</code>, <code>*</code>, etc.) with our multimethods (<code>add</code>, <code>mult</code>, etc), and also create our own implementations of <code>sqrt</code>, <code>sin</code>, <code>cos</code>, and <code>atan</code> that handled our number types. This could be done by adding new protocols. </p>

<h2 id="final-thoughts">Final Thoughts</h2>

<p>This is a nice non-trivial program from SICP that demonstrates the ideas and challenges in polymorphism. Implementing this in Clojure required us to use just about every feature for polymorphism in Clojure&#39;s core library. But I am satified with how Clojure could handle everything without any requiring any &#39;hacks&#39; or major redesigns.</p>

<p>I think that this highlights one of the good aspects of Clojure&#39;s design and philosophy. Namely, the decoupling (or &#39;decomplecting&#39;) of ideas in the language. In this demo there are the following concepts:</p>

<ol>
<li>Data (in the form of records).</li>
<li>Functions.</li>
<li>Single and multiple dispatch (protocols and multimethods) to functions.</li>
<li>Hierarchies of types.</li>
</ol>

<p>Functions and data are decoupled because records are just data and you can&#39;t attach methods onto records in Clojure the way you can with class methods in OOP. You don&#39;t need getter/setter methods because records are maps so you just the functions for maps. </p>

<p>Data and dispatch are decoupled. You do not need to know at design time which protocols or multimethods are going to use your record type. In Java where polymorphic single-dispatch is achieved via interfaces or abstract classes you need explicitly implement or extend your class when you write it. In Clojure you can add protocols or multimethods to any existing type when are where you want.</p>

<p>Dispatch in Clojure is simply a fancy wrapper for functions. For a user of a protocol, multimethod, or function it makes no difference how it is implemented - it looks exactly the same. This is a big win for extending or refactoring code without breaking things. For example, say we only had a complex type <code>complex-r</code> and implemented the methods <code>real</code>, <code>imag</code>, <code>magnitude</code>, and <code>angle</code> as functions via <code>defn</code>. But then later we required the <code>complex-p</code> type and it also needed the same methods. Refactoring the existing functions (<code>real</code>, <code>imag</code>, etc) into a protocol will make no difference to code already using these functions with the <code>complex-r</code> type - it looks and acts just like a function. Multimethods are the same. </p>

<p>Type hierarchies can be decoupled from types. In this example we built a hierarchy for the number types using namespaced keywords like <code>::complex-r</code>. This exists independently from the records we defined. It is coupled to the record types via a one-to-one mapping of the records to a keyword, implemented by the protocol <code>PNumberKind</code>. This decoupling allowed us to create further abstractions such as <code>::number</code> and <code>::complex</code>. In Java you&#39;d have to create abstract base classes retroactively and subclass the existing types, which would be a redesign. This decoupling was also useful later for the <em>numeric tower</em> where we actually required a completely different hierarchy of the types. This was made possible in Clojure because you can create multiple hierarchies ad-hoc - hierarchies are just data. You could even implement multimethods with different type hierarchies this way. In OOP this kind of polymorphic dispatch is strongly coupled to your class hierarchies, which you can&#39;t just change.</p>

<h2 id="source-code">Source Code</h2>

<p>The complete code of this tutorial can be found here: <a href="https://github.com/jimypbr/clojure-numbers">https://github.com/jimypbr/clojure-numbers</a>.</p>

<h2 id="further-reading">Further Reading</h2>

<ol>
<li>Read SICP section 2.4: <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_sec_2.4">https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_sec_2.4</a></li>
<li>Watch &#39;Simple Made Easy&#39; by Rich Hickey. It&#39;s a great talk that explains how Clojure aims to decouple key programming concepts from each other: <a href="https://www.infoq.com/presentations/Simple-Made-Easy">https://www.infoq.com/presentations/Simple-Made-Easy</a></li>
<li>For more about multiple dispatch, Eli Bendersky&#39;s series of blog posts are great: <a href="http://eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch">http://eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch</a></li>
</ol>

<p><br /><br>
<em><a href="/2016/11/polyclojure2">&gt; Click here for the previous part of this series.</a></em></p>

              </div>
			  <div class="post-footer">
				  <div class="column-full">
					  <h3><a href="/archive.html">Blog archive</a></h3>
				  </div>
			  </div>
            </div>
          </div>
        </div>
        <!--
        <div class="col-md-3 hidden-xs">
          <div class="sidebar ">
  <h1>Recent Posts</h1>
  <ul>
    
    <li><a href="/2016/12/fleuronbovw">SIFTing Images</a></li>
    
    <li><a href="/2016/11/polyclojure3">Polymorphism in Clojure: A Tutorial Using Numbers, Part 3</a></li>
    
    <li><a href="/2016/11/polyclojure2">Polymorphism in Clojure: A Tutorial Using Numbers, Part 2</a></li>
    
    <li><a href="/2016/11/polyclojure1">Polymorphism in Clojure: A Tutorial Using Numbers, Part 1</a></li>
    
    <li><a href="/2015/11/julia">Experiments with Julia</a></li>
    
  </ul>
</div>

<div class="sidebar">
  <h1>Tags</h1>
  <ul>
    
      <li><a href="/tag/julia">julia</a></li>
    
      <li><a href="/tag/c++">c++</a></li>
    
      <li><a href="/tag/simd">simd</a></li>
    
      <li><a href="/tag/clojure">clojure</a></li>
    
      <li><a href="/tag/polymorphism">polymorphism</a></li>
    
      <li><a href="/tag/functional-programming">functional-programming</a></li>
    
      <li><a href="/tag/python">python</a></li>
    
      <li><a href="/tag/machine-learning">machine-learning</a></li>
    
      <li><a href="/tag/computer-vision">computer-vision</a></li>
    
      <li><a href="/tag/opencv">opencv</a></li>
    
      <li><a href="/tag/bovw">bovw</a></li>
    
  </ul>
</div>

		</div>
		-->
      </div>
	  

    </div>
  </div>
  <footer class="footer-distributed">
<div class="container">

	<div class="footer">
	<p><a href="/about">James Briggs</a> &copy; 2015-2016</p>
		<h6>Follow me</h6>

<ul class="social-media">

    
    <li>
        <a title="jimypbr on Github"
            href="https://github.com/jimypbr"
            target="_blank"><i class="fa fa-github fa-2x"></i></a>
    </li>
    

    
    <li>
        <a title="jimy-loon on StackOverflow"
			href="http://stackoverflow.com/users/jimy-loon"
            target="_blank"><i class="fa fa-stack-overflow fa-2x"></i></a>
    </li>
    

    
    <li>
        <a title="jimypbr on LinkedIn"
            href="https://www.linkedin.com/in/james-briggs-74229a65"
            target="_blank"><i class="fa fa-linkedin fa-2x"></i></a>
    </li>
    


    


    

    
    <li>
        <a title="feed.xml RSS"
            href="/feed.xml"
            target="_blank"><i class="fa fa-rss fa-2x"></i></a>
    </li>
    

</ul>

	</div>
	<div class="theme-origin">
		<p>Powered by <a href="https://jekyllrb.com/"> Jekyll</a>. Based on the theme <a href="https://github.com/streetturtle/jekyll-clean-dark">jekyll-clean-dark</a></p>.
</div>

</footer>

<!--
  <script type="text/javascript">
    var disqus_shortname = 'jimypbr';

   (function () {
     var s = document.createElement('script'); s.async = true;
     s.type = 'text/javascript';
     s.src = '//' + disqus_shortname + '.disqus.com/count.js';
     (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
   }());
 </script>

 -->

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', '', 'auto');
    ga('send', 'pageview');
  </script>


</body>

</html>

</div>
